<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="/shared/sp-template/styles/SP-Global-2015.css">
<link rel="stylesheet" type="text/css" href="/shared/sp-template/styles/SP-bootstrap-grid.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
<script src="/shared/sp-template/scripts/jquery.ui.touch-punch.min.js"></script>
<link rel="stylesheet" type="text/css" href="/shared/sp-template/styles/jquery-ui.min.css">
<script src="/shared/sp-template/scripts/snippets/accordion.js"></script>
<script>$(document).ready(function(){$("h1:first").addClass("sr-only");});</script>
<title>Pointers, Pointer Arithmetic, and Memory Maps</title>
</head><body><h1>Pointers, Pointer Arithmetic, and Memory Maps</h1>
<h2>Quick Summary</h2>
<p><strong>Assumptions for practice:</strong> char = 1 byte, short = 2 bytes, int = 4 bytes. Examples assume little-endian for multi-byte reads.</p>
<p>A pointer stores an address. Printing any pointer with %p shows its address; dereferencing (*ptr) reads the object of the pointer’s type at that address.</p>
<p><strong>Pointer arithmetic:</strong> moves in elements, not bytes:<br><code>new_address = base_address + n * sizeof(type)</code></p>
<p><strong>Dereferencing depends on type:</strong> *cPtr → 1 byte, *sPtr → 2 bytes, *iPtr → 4 bytes.</p>
<p><strong>Operator precedence:</strong> *(cPtr + 1) ≠ *cPtr + 1.</p>
<p><strong>Bounds &amp; safety:</strong> Stay within array bounds. Casting char* to short*/int* can cause undefined behavior.</p>
<h2>Examples</h2>
<h3>Memory Map Example with "Example"</h3>
<table style="border-collapse: collapse; width: 100.013%;" border="1"><colgroup><col style="width: 33.2685%;"><col style="width: 33.2685%;"><col style="width: 33.2685%;"></colgroup></table>
<table border="1" style="border-collapse: collapse; width: 80%;">
<tbody>
<tr>
<th>Index</th>
<th>Value</th>
<th>Char</th>
</tr>
<tr>
<td>0x107</td>
<td>00</td>
<td>''</td>
</tr>
<tr>
<td>0x106</td>
<td>65</td>
<td>'e'</td>
</tr>
<tr>
<td>0x105</td>
<td>6C</td>
<td>'l'</td>
</tr>
<tr>
<td>0x104</td>
<td>70</td>
<td>'p'</td>
</tr>
<tr>
<td>0x103</td>
<td>6D</td>
<td>'m'</td>
</tr>
<tr>
<td>0x102</td>
<td>61</td>
<td>'a'</td>
</tr>
<tr>
<td>0x101</td>
<td>78</td>
<td>'x'</td>
</tr>
<tr>
<td>0x100</td>
<td>45</td>
<td>'E'</td>
</tr>
</tbody>
</table>
<p>Note: The starting address of 0x100 and that the location of each character goes up 1 space of memory. Each space is equal to one unit of memory (8 bits or 1 byte). A char is one byte big, so each slot of memory can hold one char.</p>
<p><strong>Pointers - storing a memory address:</strong></p>
<pre>char  cExample[] = "Example";
char  *cPtr = cExample;
short *sPtr = (short*)cExample;
int   *iPtr = (int*)cExample;
</pre>
<p><strong>Dereferencing - visiting a location in memory to read the valye:</strong></p>
<ul>
<li>*cPtr → 0x45 ('E')</li>
<li>*sPtr → 0x7845</li>
<li>*iPtr → 0x6D617845</li>
</ul>
<h3>Pointer Arithmetic Examples</h3>
<pre>cPtr + 1 → points to 'x' (byte 1)
*(cPtr + 1) → 0x78 ('x')
sPtr + 1 → points to 'a' 'm' (bytes 2..3)
*(sPtr + 1) → 0x6D61
</pre>
<pre></pre>
<h2>Pointer math with different data types</h2>
<p>Consider the following unsigned integer: 1,398,030,674, and lets put that into memory. We'll also create a char pointer and assign it the address of our int</p>
<pre class="line-numbers d2l-code"><code class="language-c">//Declare the number
int theNumber = 1398030674;
//create a character pointer, and assign it the value of theNumbers address.
char *charPointer = &amp;theNumber; //reminder that ampersand (&amp;) grabs the address of a variable, not the value stored there</code></pre>
<p>Lets assume that <strong>theNumber </strong>get the address 0x120, and fill in our memory map table with the converted hexadecimal values, we'll treat the <strong>charPointer </strong>as a 4 byte address for this exercise<br>1398030674 = 0x53544152</p>
<table style="border-collapse: collapse; width: 100.013%; height: 313.2px;" border="1"><colgroup><col style="width: 33.3009%;"><col style="width: 33.3009%;"><col style="width: 33.3009%;"></colgroup>
<tbody>
<tr style="height: 34.8px;">
<td>Address</td>
<td>Alias</td>
<td>Value</td>
</tr>
<tr style="height: 34.8px;">
<td style="width: 48pt;">0x127</td>
<td></td>
<td>0x00</td>
</tr>
<tr style="height: 34.8px;">
<td>0x126</td>
<td></td>
<td>0x00</td>
</tr>
<tr style="height: 34.8px;">
<td>0x125</td>
<td></td>
<td>0x01</td>
</tr>
<tr style="height: 34.8px;">
<td>0x124</td>
<td>charPointer</td>
<td>0x20</td>
</tr>
<tr style="height: 34.8px;">
<td>0x123</td>
<td></td>
<td>0x53</td>
</tr>
<tr style="height: 34.8px;">
<td>0x122</td>
<td></td>
<td>0x54</td>
</tr>
<tr style="height: 34.8px;">
<td>0x121</td>
<td></td>
<td>0x41</td>
</tr>
<tr style="height: 34.8px;">
<td>0x120</td>
<td>theNumber</td>
<td>0x52</td>
</tr>
</tbody>
</table>
<p><strong>charPointer </strong>stores the address to <strong>theNumber,</strong>&nbsp;we can access the values stored there and de-reference them as a char rather than an integer. This is because the Data Type of the Pointer determines how the data is read, and in how many chunks. A char pointer reads one byte values.</p>
<p>&nbsp;</p>
<section class="d2l-cplus-layout d2l-cplus-layout-two-third" aria-label="layout with a large panel followed by a smaller panel" tabindex="-1">
<section class="d2l-cplus-layout-column" aria-label="panel 1 of 2" tabindex="-1">
<pre class="line-numbers d2l-code"><code class="language-c">printf("The value of charPointer at the position + 0 is : %c\n", *charPointer);
printf("The value of charPointer at the position + 1 is : %c\n", *(charPointer + 1));
printf("The value of charPointer at the position + 2 is : %c\n", *(charPointer + 2));
printf("The value of charPointer at the position + 3 is : %c\n", *(charPointer + 3));

//This will print out the hexadecimal value of each slot as a character
//rather than all four slots as one iteger</code></pre>
</section>
<section class="d2l-cplus-layout-column" aria-label="panel 2 of 2" tabindex="-1">
<p><img src="image_20260112172358713.png" style="max-width: 100%;" data-d2l-editor-default-img-style="true"></p>
</section>
</section>
<h2>&nbsp;Review:</h2>
<ul>
<li>Variables like <strong>theNumber </strong>store values in a byte space who's size is determined by the data type , EG <strong>theNumber </strong>holds the value1398030674</li>
<li>Variables like <strong>theNumber </strong>themselves have an address, which your computer uses to find the alias of the variable, the address is always the START of the byte space reserved for that variable</li>
<li>Pointers like <strong>charPointer </strong>store address as their value, EG charPointer stores the address of theNumber = 0x120</li>
<li>Pointers like <strong>charPointer </strong>themselves have an address that your computer uses to find the alias of the pointer.</li>
<li>When adding and integer to a pointer, the amount of space it moves is equal to the integer * the Byte Space size of the data type the pointer repersents, EG charPointer + 1 moves by one byte, but if we had an intPointer + 1, it would move up 4 bytes, or the size of an int.</li>
<li>Pointers can be DEREFERENCED, which means the computer will read the address stored in the Pointer, and go to that address. It will then read the address as the DATATYPE PROVIDED BY THE POINTER.
<ul>
<li>functionally, every time you call a basic variable, it is dereferencing itself, this is true for nearly all computing languages.&nbsp;</li>
</ul>
</li>
<li>Variable addresses can be viewed with the Ampersand (&amp;) Operator, this will show where the first slot of memory is for any variable.</li>
<li>These actions can be applied to single variables, arrays, and structs. We will cover those in greater detail when we encounter them in the course</li>
</ul></body></html>