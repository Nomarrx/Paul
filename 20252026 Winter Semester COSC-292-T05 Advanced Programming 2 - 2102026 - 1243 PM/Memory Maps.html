<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="/shared/sp-template/styles/SP-Global-2015.css">
<link rel="stylesheet" type="text/css" href="/shared/sp-template/styles/SP-bootstrap-grid.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
<script src="/shared/sp-template/scripts/jquery.ui.touch-punch.min.js"></script>
<link rel="stylesheet" type="text/css" href="/shared/sp-template/styles/jquery-ui.min.css">
<script src="/shared/sp-template/scripts/snippets/accordion.js"></script>
<script>$(document).ready(function(){$("h1:first").addClass("sr-only");});</script>
<title>Lesson — Memory Maps</title>
</head><body><h1>Lesson — Memory Maps</h1>
<div class="row">
<div class="col-sm-12">
<p><strong>Learning Outcome(s):</strong> LO5 — Develop code to reference and manipulate static memory with pointers.</p>
<p><strong>Assessment alignment:</strong> Midterm 1 (Memory map exercises).</p>
</div>
</div>
<h2>Memory Maps</h2>
<p>When we write out the addresses, aliases, and values of the bytes in a computer’s memory, we are creating a <strong>memory map</strong>. Memory maps can be useful in understanding how values are stored, how we can manipulate those values, and how pointers work.</p>
<h3>Project Setup</h3>
<p>Create a new project to demonstrate memory maps. Create separate files with one file named <code>program.c</code> for the main function and one file named <code>memory.c</code> for a function named <code>memoryMap</code> that takes in a <code>float</code> and returns an <code>int</code>. Create an appropriate header file named <code>memory.h</code> as well. The main function should simply create a float variable and call the <code>memoryMap</code> function.</p>
<h3>Source Files</h3>
<h4>program.c</h4>
<pre class="line-numbers d2l-code"><code class="language-c">#include &lt;stdlib.h&gt;
#include "memory.h"

void main(void)
{
    float passingGrade = 49.5f;
    memoryMap(passingGrade);

}</code></pre>
<pre></pre>
<h4>memory.h</h4>
<pre class="line-numbers d2l-code"><code class="language-c">#ifndef MEMORY_H
#define MEMORY_H

// Prototype the function. Note that the formal parameter name is optional.
int memoryMap(float);

#endif // !MEMORY_H</code></pre>
<pre></pre>
<p>Note that a header guard is used; alternatively, you may use <code>#pragma once</code>.</p>
<h4>memory.c</h4>
<pre class="line-numbers d2l-code"><code class="language-c">#include &lt;stdio.h&gt;
#include "memory.h"


int memoryMap(float x)
{
	printf("The value of the argument is %f", x);

	//Variables to work with
	static int i = 0;
	int a = 1235257896;
	double d = 9.0;
	int* iPtr = &amp;a;
	char c = 'a';
	short s = 10815;
	char cArray[] = "Hello";


	printf("The value of the argument is %f\n", x);
	// Address of the parameter
	printf("The address of float x is \t%p\n", &amp;x);

	// Print the address of each variable
	// The "Address of" operator is the overloaded &amp;
	// Note that %p is used for printing addresses in hexadecimal
	printf("The address of int i is \t%p\n", &amp;i);
	printf("The address of int a is \t%p\n", &amp;a);
	printf("The value of int a in hex is \t%x\n", a); // %x says print in hex
	// We can print an int as a char - prints only least significant byte
	printf("The value of a as a char is \t%c\n\n", a);

	printf("The address of double d is \t%p\n", &amp;d);
	printf("The address of pointer iPtr is \t%p\n", &amp;iPtr);
	printf("The value stored in iPtr is \t%p\n", iPtr);
	printf("The address of char c is \t%p\n", &amp;c);
	printf("The value of c in hex is \t%x\n\n", c);

	printf("The address of short s is \t%p\n", &amp;s);
	printf("The value of s in hex is \t%x\n", s);
	// We can print a short as a char - prints only least significant byte
	printf("The value of s as a char is \t%c\n\n", s);

	// Note that the name of an array IS its address. &amp; is not required.
	printf("The address of cArray is \t%p\n", cArray);
	printf("The address of cArray is \t%p\n", &amp;cArray); // &amp; will still work
	//Observe that the character array increases by one value for each
	//the starting address of the first letter is the same as the array itself. the last value is the end of the array.
	for (int iterator = sizeof(cArray)-1; iterator &gt;= 0 ; iterator--)
	{
		printf("The address of cArray Element %d is \t%p \t Element Value = %c\n", iterator, &amp;cArray[iterator], cArray[iterator]);
	}
	//More later on arrays!

	// Print the address of the function itself.
	// Note that the name of the function stores its address.
	printf("The address of memoryMap is \t%p\n", memoryMap);

	return 0;
}
</code></pre>
<pre><code class="language-c"></code></pre>
<pre><code class="language-c"></code></pre>
<h3>Notes on Addresses and Visual Studio Setting</h3>
<p>&nbsp;</p>
<section class="d2l-cplus-layout d2l-cplus-layout-two-third" aria-label="layout with a large panel followed by a smaller panel" tabindex="-1">
<section class="d2l-cplus-layout-column" aria-label="panel 1 of 2" tabindex="-1">
<p>Try running the program. You will see that the addresses change every time that the program runs. The changing addresses are because by default, Visual Studio 2022 randomizes the base address of the program for additional security.</p>
<p>To change this default property and make it easier to create a memory map, set: <strong>Project → Properties → Configuration Properties → Linker → All Options → Randomized Base Address: No (/DYNAMICBASE:NO)</strong>.</p>
<p>Note that if you switch from the <em>Debug</em> to the <em>Release</em> configuration or from the <em>x64</em> to <em>x86</em> platform, you must set this property for <strong>each configuration</strong>. Start in the Debug configuration for x86.</p>
</section>
<section class="d2l-cplus-layout-column" aria-label="panel 2 of 2" tabindex="-1">
<p><img src="image_20260112153939103.png" style="max-width: 100%;" data-d2l-editor-default-img-style="true"></p>
</section>
</section>
<p>&nbsp;</p>
<h3>Worksheet Setup</h3>
<p>To create a memory map for this program, download <em>Memory Map Template.xlsx</em> from the Notes folder. Open the file and you will see that it has a block of addresses (going up from bottom to top and from right to left). Save the file as <em>Memory Map Debug.xlsx</em> (keeping the template clean for later use).</p>
<p>Change the <strong>Data Type of Highest Addressed</strong> in cell D1 (so there is enough space for that type), then in cell D2 type the highest address. The worksheet updates automatically.</p>
<h4>Example values</h4>
<table border="1" cellpadding="4">
<tbody>
<tr>
<th>Data Type of Highest Addressed</th>
<th>Address of Highest</th>
</tr>
<tr>
<td>float</td>
<td>0019FE08</td>
</tr>
</tbody>
</table>
<p>For a readable mapping: run your program, resize the console window smaller, press <kbd>Alt</kbd>+<kbd>Print Screen</kbd> to copy an image of the output, and paste it into cell A31 in the worksheet.</p>
<h3>Building the Map</h3>
<ul>
<li>Add variable names in the <strong>Alias</strong> column. Do <em>not</em> add aliases for <code>i</code> (the <code>static int</code>) and for the function <code>memoryMap</code> itself — they are in different areas of memory (we will discuss areas later).</li>
<li>Be careful to add the alias for <code>iPtr</code> at the <strong>address of iPtr</strong>, <em>not</em> its value (which equals the address of <code>a</code>).</li>
<li>Use background colors to highlight each variable’s byte range. Addresses go up from the bottom, so each variable’s block goes upward from its alias address.</li>
</ul>
<h4>Sizes to remember (x86)</h4>
<ul>
<li>float = 4 bytes</li>
<li>int = 4 bytes</li>
<li>double = 8 bytes</li>
<li>pointer = 4 bytes (x86) / 8 bytes (x64)</li>
<li>char = 1 byte</li>
<li>short = 2 bytes</li>
<li><code>cArray[] = "Hello"</code> → 6 bytes (includes null terminator)</li>
</ul>
<h3>Fill in Values (little-endian)</h3>
<p>Add the values (in hex) for <code>int a</code>, <code>short s</code>, <code>char c</code>, <code>cArray</code> (characters going up from <code>'H'</code> at the bottom to the null terminator at the top), and <code>iPtr</code>. Write <strong>all values in little-endian notation</strong>.</p>
<p>Do not worry about writing values for <code>float x</code> or <code>double d</code> — that requires understanding the internal floating-point format.</p>
<h3>Debug vs Release observations (x86)</h3>
<ul>
<li>In <strong>Debug</strong>, the compiler places extra information in memory, so variables may be further apart than necessary.</li>
<li>On x86 (32-bit), variables typically start at a 4-byte boundary (except <code>char c</code>) — faster fetches may create small gaps (e.g., 2 bytes above <code>short s</code>).</li>
<li>In <strong>Release</strong>, the arrangement is tighter, often eliminating wasted space between variables (with small exceptions near <code>char c</code>, <code>short s</code>, and after parameter <code>float x</code>).</li>
</ul>
<h3>Pointer Addresses vs Values</h3>
<p>The <strong>address of <code>iPtr</code></strong> is the location where the pointer variable itself is stored. The <strong>value of <code>iPtr</code></strong> is also an address — in this case, the address of <code>a</code>. Dereferencing <code>iPtr</code> with <code>*iPtr</code> gives the value stored at that address: the value of <code>a</code>.</p>
<div class="msgHead accor_ref" style="clear: both;">
<h2>Reference(s)</h2>
</div>
<div class="msgBody accor_ref_body">
<p>Microsoft Learn. C runtime library reference. Retrieved from https://learn.microsoft.com/en-us/cpp/c-runtime-library/</p>
<p>Wikipedia contributors. Memory map. Retrieved from https://en.wikipedia.org/wiki/Memory_map</p>
</div></body></html>